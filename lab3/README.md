# Минимальное Остовное Дерево (MST) - Алгоритм Краскала

## Описание Задачи

Дано `n` точек на плоскости с координатами `(xi, yi)`. Требуется соединить эти точки отрезками таким образом, чтобы:

1.  Из любой точки можно было добраться до любой другой (возможно, через промежуточные точки). То есть, все точки должны быть связаны в единую компоненту связности.
2.  Суммарная длина всех использованных отрезков была минимальной.

Длина отрезка между точками `(x1, y1)` и `(x2, y2)` вычисляется по формуле евклидова расстояния: `sqrt((x1 - x2)^2 + (y1 - y2)^2)`.

Эта задача является классической задачей поиска **Минимального Остовного Дерева (Minimum Spanning Tree, MST)** в полном неориентированном взвешенном графе. Вершинами графа являются заданные точки, а ребрами - все возможные отрезки между парами точек. Вес каждого ребра равен длине соответствующего отрезка (евклидову расстоянию).

## Используемый Алгоритм: Алгоритм Краскала

Для решения задачи используется **алгоритм Краскала**. Это жадный алгоритм, который строит MST шаг за шагом, добавляя ребра в порядке возрастания их весов.

**Основные шаги алгоритма:**

1.  **Создание ребер:** Сгенерировать список всех возможных ребер (отрезков) между каждой парой заданных точек. Для каждого ребра вычислить его вес (длину).
2.  **Сортировка ребер:** Отсортировать список всех ребер по возрастанию их весов.
3.  **Инициализация DSU:** Создать Систему Непересекающихся Множеств (Disjoint Set Union, DSU). Изначально каждая точка (вершина) находится в своем собственном множестве. Эта структура данных будет использоваться для эффективного отслеживания компонент связности и предотвращения циклов.
4.  **Построение MST:**
    *   Инициализировать переменную `minimum_total_length = 0.0` для хранения суммарной длины MST.
    *   Инициализировать счетчик добавленных ребер `edges_in_mst = 0`.
    *   Перебирать отсортированные ребра от самого легкого к самому тяжелому.
    *   Для каждого ребра `(u, v)` с весом `w`:
        *   Проверить с помощью DSU (операция `find_set`), принадлежат ли вершины `u` и `v` разным множествам (разным компонентам связности).
        *   **Если `u` и `v` в разных множествах:**
            *   Добавить ребро в MST: прибавить его вес `w` к `minimum_total_length`.
            *   Объединить множества, содержащие `u` и `v`, с помощью DSU (операция `unite_sets`). Это означает, что добавление этого ребра не создает цикл.
            *   Увеличить счетчик `edges_in_mst` на 1.
        *   **Если `u` и `v` уже в одном множестве:** Пропустить это ребро, так как его добавление создаст цикл.
    *   Алгоритм завершается, когда в MST будет добавлено `n - 1` ребро (где `n` - количество точек), так как остовное дерево для `n` вершин всегда содержит ровно `n - 1` ребро.
5.  **Результат:** Значение `minimum_total_length` является искомой минимальной суммарной длиной ребер MST.

## Необходимая Теория

Для понимания и решения задачи полезно знать следующие концепции:

1.  **Граф:** Математическая структура, состоящая из *вершин* (в нашем случае - точки) и *ребер* (отрезки), соединяющих некоторые пары вершин. В данной задаче мы имеем дело с *полным*, *неориентированным*, *взвешенным* графом.
2.  **Остовное Дерево (Spanning Tree):** Подграф связного графа, который включает все вершины исходного графа и является деревом (т.е. не содержит циклов).
3.  **Минимальное Остовное Дерево (MST):** Остовное дерево, у которого сумма весов всех входящих в него ребер минимальна среди всех возможных остовных деревьев данного графа.
4.  **Жадный Алгоритм (Greedy Algorithm):** Алгоритм, который на каждом шаге делает локально оптимальный выбор в надежде найти глобальный оптимум.
5.  **Система Непересекающихся Множеств (Disjoint Set Union - DSU):** Структура данных для эффективного отслеживания компонент связности и объединения множеств.
6.  **Евклидово Расстояние:** Стандартная метрика расстояния: `sqrt((x1 - x2)^2 + (y1 - y2)^2)`.

## Описание Функций Кода

Основная логика реализована в файле `mst_solver.py`.

*   **`calculate_distance(point1, point2)`**: Вычисляет евклидово расстояние между двумя точками.
*   **`calculate_mst_length(points_coords)`**: Основная функция, реализующая алгоритм Краскала. Принимает список координат точек, возвращает длину MST. Включает реализацию DSU.

## Формат Входных и Выходных Данных

**Входной файл (`input.txt`):**

1.  Первая строка: целое число `n` (1 ≤ n ≤ 200) - количество точек.
2.  Следующие `n` строк: координаты точек `xi yi` (-1000 ≤ xi, yi < 1000), разделенные пробелом. Гарантируется, что все точки различны и никакие три точки не лежат на одной прямой.

**Выходной файл (`output.txt`):**

1.  Одна строка: действительное число - минимальная суммарная длина отрезков. Ответ должен быть выведен с точностью не менее 7 знаков после запятой (в коде используется 9 для надежности).

## Примеры

**Пример 1:**

*   **`input.txt`:**
    ```
    4
    0 0
    0 1
    1 0
    1 1
    ```
*   **`output.txt`:**
    ```
    3.000000000
    ```

**Пример 2:**

*   **`input.txt`:**
    ```
    5
    0 0
    0 2
    1 1
    3 0
    3 2
    ```
*   **`output.txt`:**
    ```
    7.064495102
    ```

## Запуск Кода

1.  Сохраните код как `mst_solver.py`.
2.  Создайте файл `input.txt` в той же директории, где находится `mst_solver.py`, и поместите в него входные данные в соответствии с форматом.
3.  Запустите скрипт из терминала:
    ```bash
    python mst_solver.py
    ```
4.  Скрипт автоматически прочитает данные из `input.txt` и создаст (или перезапишет) файл `output.txt` с результатом в той же директории.

## Запуск Тестов

Для проверки корректности основной логики (функции `calculate_mst_length`) предусмотрены модульные тесты в файле `tests.py`. **Тесты не используют файлы `input.txt` или `output.txt`.**

1.  Убедитесь, что файлы `mst_solver.py` и `tests.py` находятся в одной директории.
2.  Запустите тесты из терминала командой:
    ```bash
    python -m unittest tests.py
    ```
3.  Вы увидите отчет о прохождении тестов. `OK` означает, что все тесты прошли успешно.