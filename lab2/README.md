# 18 задача (5б)

## Локальность доступа к элементам

- **Пространственная локальность:**
  - **Описание:**  
    Splay-дерево реализовано с использованием указателей, что приводит к тому, что узлы дерева распределены в динамической памяти (heap) нерегулярно.  
  - **Обоснование:**  
    Поскольку узлы выделяются в разные участки памяти (не последовательно, как в массиве), при последовательном обходе дерева процессор может сталкиваться с "разбросанными" данными, что негативно влияет на использование кэша. Это означает, что даже если два узла логически соседние, они могут находиться далеко друг от друга в памяти, снижая эффективность кэширования.

- **Временная локальность:**
  - **Описание:**  
    При каждом обращении к узлу в splay-дереве выполняется операция **splaying** – узел поднимается к корню дерева.  
  - **Обоснование:**  
    Если одни и те же узлы часто запрашиваются (например, при повторном поиске или модификации), они оказываются ближе к корню. Это означает, что эти узлы скорее всего уже загружены в кэш процессора благодаря недавнему доступу. Таким образом, даже при плохой пространственной локальности, временная локальность улучшается за счёт частого доступа к недавно использованным узлам.

## Временная сложность операций в Splay-дереве

- **Поиск (Search):**
  - **Амортизированная сложность:** O(log n)
  - **Худший случай:** O(n)
  - **Обоснование:**  
    Каждая операция поиска сопровождается операцией splaying, которая перемещает найденный узел к корню. Амортизированный анализ показывает, что суммарное время последовательности операций является O(log n) на операцию, хотя в отдельном случае (например, если дерево сильно «развешано») поиск может потребовать обхода всех n узлов. Таким образом, средняя производительность остаётся эффективной при случайном доступе.

- **Вставка (Insertion):**
  - **Амортизированная сложность:** O(log n)
  - **Обоснование:**  
    При вставке новый узел добавляется в дерево, а затем происходит splaying этого узла к корню. Благодаря амортизированному анализу, несмотря на возможное выполнение нескольких вращений, средняя сложность остаётся O(log n). Это связано с тем, что splaying балансирует дерево, предотвращая его деградацию.

- **Удаление (Deletion):**
  - **Амортизированная сложность:** O(log n)
  - **Обоснование:**  
    Удаление узла включает сначала splaying удаляемого узла к корню, затем объединение двух поддеревьев. Хотя отдельное удаление может временно привести к неидеальному распределению узлов, амортизированный анализ показывает, что затраты остаются O(log n) при последовательных операциях.

- **Операция splay (подъём узла):**
  - **Амортизированная сложность:** O(log n)
  - **Обоснование:**  
    Splaying может потребовать выполнения нескольких последовательных вращений (zig-zig, zig-zag). В худшем случае количество вращений может достигать O(n), но амортизированный анализ (например, с использованием метода потенциалов) показывает, что среднее число операций за последовательность запросов остаётся O(log n).

- **Операции split и merge:**
  - **Амортизированная сложность:** O(log n)
  - **Обоснование:**  
    Оба эти алгоритма базируются на операции splaying. Split находит нужный узел, поднимает его к корню, а затем разделяет дерево, что занимает O(log n) амортизированного времени. Merge объединяет два дерева, сначала поднимая максимальный узел из левого дерева, что также работает за O(log n) амортизированного времени.

> **Итоговое Обоснование:**  
> Несмотря на то, что отдельные операции могут в худшем случае достигать линейной сложности, амортизированный анализ последовательности операций в splay-дереве гарантирует, что среднее время работы каждой операции составляет O(log n). Это делает splay-дерево эффективной структурой данных для динамических наборов, где важна частота повторного доступа к данным.
