**1. Какая временная сложность у алгоритма?**

Алгоритм состоит из двух основных частей:

1.  **Предварительное вычисление хешей и степеней:** Для строк `s` и `t` это занимает O(|s| + |t|) времени, так как нужно пройти по каждой строке один раз.
2.  **Бинарный поиск по длине + Проверка (`check`):**
    *   Бинарный поиск выполняется по возможной длине `l`, которая находится в диапазоне `[0, min(|s|, |t|)]`. Количество итераций бинарного поиска составляет O(log(min(|s|, |t|))).
    *   На каждой итерации бинарного поиска вызывается функция `check(k)` (в коде `check_substring_existence`). Эта функция:
        *   Вычисляет и сохраняет хеши всех подстрок длины `k` из `s` в хеш-таблицу (словарь). Это занимает O(|s|) времени в среднем (O(1) на вычисление хеша и O(1) на вставку в словарь).
        *   Вычисляет хеши всех подстрок длины `k` из `t` и проверяет их наличие в хеш-таблице. Это занимает O(|t|) времени в среднем (O(1) на вычисление хеша и O(1) на поиск в словаре).
        *   Итого, функция `check` работает за O(|s| + |t|) в среднем.

Общая временная сложность алгоритма складывается из предобработки и бинарного поиска, умноженного на сложность проверки:
O(|s| + |t|) + O(log(min(|s|, |t|)) * (|s| + |t|)) = **O((|s| + |t|) * log(min(|s|, |t|)))** в среднем.

*Примечание: Сложность указана "в среднем" из-за использования хеш-таблиц, операции в которых (вставка, поиск) имеют среднюю сложность O(1), но в худшем (теоретическом) случае могут деградировать до O(N).*

**2. Опишите, как двоичный поиск используется для определения максимальной длины общей подстроки и как происходит проверка на наличие общей подстроки заданной длины?**

*   **Двоичный поиск по длине:**
    *   **Цель:** Найти *максимальное* значение длины `l`, для которого существует хотя бы одна общая подстрока между `s` и `t`.
    *   **Свойство:** Если существует общая подстрока длины `k`, то гарантированно существует общая подстрока любой длины `m < k` (например, префикс той же подстроки). Это свойство монотонности позволяет применить бинарный поиск.
    *   **Процесс:**
        1.  Задаем диапазон поиска для длины `l`: от `low = 0` до `high = min(|s|, |t|)`.
        2.  Инициализируем переменные для хранения лучшего найденного результата: `best_l = 0`, `best_i = 0`, `best_j = 0`.
        3.  Пока `low <= high`:
            *   Вычисляем середину диапазона: `mid = low + (high - low) // 2`.
            *   **Вызываем функцию проверки `check(mid)`**, чтобы узнать, существует ли общая подстрока длины `mid`.
            *   **Если `check(mid)` возвращает `True`** (и индексы `i`, `j`): Это означает, что длина `mid` достижима. Мы сохраняем этот результат (`best_l = mid`, `best_i = i`, `best_j = j`) как потенциально лучший и пытаемся найти *еще большую* длину, сдвигая нижнюю границу поиска: `low = mid + 1`.
            *   **Если `check(mid)` возвращает `False`**: Это означает, что длина `mid` слишком велика. Нужно искать подстроку *меньшей* длины, сдвигая верхнюю границу поиска: `high = mid - 1`.
        4.  Когда `low` становится больше `high`, поиск завершается. Значения `best_l`, `best_i`, `best_j` содержат параметры наибольшей общей подстроки, найденной в процессе.

*   **Проверка наличия общей подстроки длины `k` (функция `check(k)`):**
    *   **Цель:** Эффективно определить, есть ли *хотя бы одна* подстрока длины `k`, которая присутствует и в `s`, и в `t`.
    *   **Использование хеширования:** Чтобы не сравнивать подстроки напрямую (что было бы долго), мы сравниваем их хеш-значения. Для повышения надежности и уменьшения вероятности коллизий (когда разные строки дают одинаковый хеш) используется несколько хеш-функций с разными параметрами (основаниями и модулями).
    *   **Процесс:**
        1.  Создается пустая хеш-таблица (словарь) `hashes_s`.
        2.  Проходим по всем возможным начальным позициям `i` для подстроки длины `k` в строке `s`.
        3.  Для каждой подстроки `s[i : i+k]` вычисляется кортеж из хешей (по одному хешу для каждой хеш-функции).
        4.  Этот кортеж хешей используется как ключ в словаре `hashes_s`, а значением сохраняется индекс `i`. Если такой ключ уже есть, значение можно не обновлять (нам достаточно найти любое вхождение).
        5.  Проходим по всем возможным начальным позициям `j` для подстроки длины `k` в строке `t`.
        6.  Для каждой подстроки `t[j : j+k]` вычисляется аналогичный кортеж хешей.
        7.  Проверяется, существует ли такой кортеж хешей как ключ в словаре `hashes_s`.
        8.  **Если ключ найден:** Это означает (с высокой вероятностью), что подстрока `t[j : j+k]` совпадает с подстрокой `s[hashes_s[key] : hashes_s[key]+k]`. Функция немедленно возвращает `True` и соответствующие индексы (`hashes_s[key]`, `j`).
        9.  **Если прошли все подстроки `t` и совпадений не найдено:** Общей подстроки длины `k` нет. Функция возвращает `False` и условные индексы (например, 0, 0).

**3. Как можно представить процесс нахождения общей подстроки, используя графические или текстовые методы?**

*   **Текстовое представление:**
    *   **Бинарный поиск:**
        ```
        Ищем НОП для s="cool", t="toolbox" (min_len=4)
        low=0, high=4
        mid=2, check(2): Ищем общую подстроку длины 2...
          Хеши s[0:2]="co", s[1:3]="oo", s[2:4]="ol" -> {hash(co):0, hash(oo):1, hash(ol):2}
          Хеши t[0:2]="to", t[1:3]="oo", t[2:4]="ol", t[3:5]="lb", t[4:6]="bo", t[5:7]="ox"
          Нашли hash(oo) в словаре s (i=1). Нашли hash(ol) в словаре s (i=2).
          check(2) -> True (например, i=1, j=1).
        Сохраняем результат (1, 1, 2). Ищем длиннее: low=3, high=4
        mid=3, check(3): Ищем общую подстроку длины 3...
          Хеши s[0:3]="coo", s[1:4]="ool" -> {hash(coo):0, hash(ool):1}
          Хеши t[0:3]="too", t[1:4]="ool", t[2:5]="olb", t[3:6]="lbo", t[4:7]="box"
          Нашли hash(ool) в словаре s (i=1).
          check(3) -> True (i=1, j=1).
        Сохраняем результат (1, 1, 3). Ищем длиннее: low=4, high=4
        mid=4, check(4): Ищем общую подстроку длины 4...
          Хеши s[0:4]="cool" -> {hash(cool):0}
          Хеши t[0:4]="tool", t[1:5]="oolb", t[2:6]="olbo", t[3:7]="lbox"
          Совпадений нет.
          check(4) -> False.
        Ищем короче: high=3.
        low=4, high=3. Цикл завершен.
        Итоговый результат: (1, 1, 3)
        ```
*   **Графическое представление:**
    *   **Бинарный поиск:** Можно изобразить числовую ось с отметками длин от 0 до `min(|s|, |t|)`. Стрелками показывать сужение диапазона `[low, high]` на каждой итерации.
    *   **Функция `check(k)`:**
        *   Нарисовать строки `s` и `t` одна под другой.
        *   Выделить "окна" длины `k`, скользящие по строкам.
        *   Нарисовать блок "Хеш-таблица S".
        *   Стрелками показать: хеш окна из `s` -> запись в таблицу.
        *   Стрелками показать: хеш окна из `t` -> поиск в таблице.
        *   Выделить совпадающие окна в `s` и `t` при успешном поиске в таблице.

        ```
        s: | c | o | o | l |
        t: | t | o | o | l | b | o | x |

        k=3:
        Окно S: [coo]       [ool]
                 |           |
                 v           v
        Хеш-таблица S: { H(coo):0, H(ool):1 }
                 ^           ^
                 |           |
        Окно T: [too]  ->  [ool]  ->  [olb] -> ...
                        (Найдено H(ool)!) -> return True, i=1, j=1
        ```

**4. Какие тестовые случаи вы бы использовали для проверки корректности и производительности вашего алгоритма?**

*   **Корректность:**
    *   **Примеры из условия:** `cool toolbox`, `aaa bb`, `aabaa babbaab` - базовая проверка.
    *   **Пустые строки:** Одна или обе строки пустые (алгоритм должен вернуть `0, 0, 0`).
    *   **Идентичные строки:** `s = "abcabc"`, `t = "abcabc"` (результат `0, 0, 6`).
    *   **Одна строка - подстрока другой:** `s = "abc"`, `t = "xyzabcxyz"` (результат `0, 3, 3`). `s = "xyzabcxyz"`, `t = "abc"` (результат `3, 0, 3`).
    *   **Нет общих подстрок (кроме пустой):** `s = "abc"`, `t = "def"` (результат `0, 0, 0`).
    *   **Только один общий символ:** `s = "apple"`, `t = "orange"` (результат `(0, 2, 1)` для 'a' или `(4, 5, 1)` для 'e').
    *   **Несколько НОП одинаковой длины:** `s = "banana"`, `t = "cabana"` (НОП "bana" и "ana". Макс. длина 3 для "ana". Результат `(1, 3, 3)` или `(3, 3, 3)`). `s = "aabaa"`, `t = "babbaab"` (НОП "aab" и "baa". Результат `(0, 4, 3)` или `(2, 3, 3)`).
    *   **Перекрывающиеся НОП:** `s = "ababab"`, `t = "baba"` (НОП "baba". Результат `(1, 0, 4)`).
    *   **Длинные строки с повторениями:** `s = "a" * 1000`, `t = "a" * 1000` (проверка на переполнение, корректность хешей). `s = "ab" * 500`, `t = "ba" * 500`.
    *   **Разные регистры (если применимо):** Убедиться, что сравнение регистрозависимое (как `ord()` работает).
    *   **Специальные символы (если применимо):** Проверить, как хеширование работает с символами вне 'a'-'z'.

*   **Производительность:**
    *   **Максимальные длины строк:** `|s|` и `|t|` близки к 200000 и 100000 соответственно, суммарная длина близка к лимитам.
    *   **НОП очень короткая:** `s = "a" * N`, `t = "b" * M` (НОП = 0). Бинарный поиск должен быстро сойтись к 0.
    *   **НОП очень длинная:** `s = "a" * N`, `t = "a" * N` (НОП = N). Бинарный поиск должен быстро сойтись к N.
    *   **НОП средней длины:** Случайные строки или строки с известной НОП примерно `min(|s|, |t|) / 2`.
    *   **Много пар строк во входном файле:** Проверить общую производительность на большом количестве тестов в рамках одного запуска.
    *   **Потенциальные коллизии (сложно создать намеренно):** Строки, которые могут с большей вероятностью дать одинаковые хеши при использовании одной хеш-функции (но маловероятно при нескольких).