# Longest Common Substring Finder (Hashing + Binary Search)

## Задача

Даны две строки `s` и `t`. Требуется найти строку `w` максимальной длины, которая является подстрокой как `s`, так и `t`. Необходимо вывести три целых числа: начальную позицию `w` в `s` (индекс `i`), начальную позицию `w` в `t` (индекс `j`) и длину `w` (длина `l`). Если существует несколько таких троек `(i, j, l)` с максимальной `l`, можно вывести любую из них.

## Решение

Алгоритм использует комбинацию бинарного поиска по длине и полиномиального хеширования для эффективной проверки наличия общей подстроки заданной длины.

1.  **Бинарный поиск:** Мы ищем максимальную длину `l` (от 0 до `min(len(s), len(t))`) такую, что существует общая подстрока длины `l`.
2.  **Проверка (`check(k)`):** Для проверки, существует ли общая подстрока длины `k`, используется полиномиальное хеширование:
    *   Вычисляются хеши всех подстрок длины `k` для строки `s`. Для надежности и уменьшения вероятности коллизий используются **две разные хеш-функции** (с разными базами и модулями). Хеши (пары значений) и соответствующие им начальные индексы сохраняются в хеш-таблицу (словарь Python).
    *   Вычисляются хеши всех подстрок длины `k` для строки `t` (также с использованием двух хеш-функций).
    *   Для каждой подстроки `t` проверяется, присутствует ли ее пара хешей в хеш-таблице, созданной для `s`. Если совпадение найдено, значит, общая подстрока длины `k` существует.
3.  **Хеширование:** Используется класс `Hasher` для эффективного вычисления хешей подстрок за O(1) после предварительного расчета префиксных хешей и степеней базы за O(N), где N - длина строки.

Общая временная сложность алгоритма составляет O((|s| + |t|) * log(min(|s|, |t|))), что является "почти линейным" временем и удовлетворяет ограничениям задачи.

## Структура проекта
~~~
├── main.py # Главный скрипт для чтения/записи файлов и вызова решателя
├── solver.py # Модуль с основной логикой (Hasher, find_longest_common_substring)
├── tests/ # Директория с тестами
│ └── test_solver.py # Модульные тесты для solver.py
├── input.txt # Пример входного файла
├── output.txt # Выходной файл (создается после запуска)
└── README.md # Этот файл
~~~
## Требования

*   Python 3.6 или выше.
*   Внешние библиотеки не требуются (используется только стандартная библиотека Python).

## Использование

1.  **Подготовка:**
    *   Поместите входные данные в файл `input.txt`. Каждая строка файла должна содержать ровно две строки `s` и `t`, разделенные пробелом.
    ```
    cool toolbox
    aaa bb
    aabaa babbaab
    ```

2.  **Запуск:**
    *   Выполните главный скрипт из корневой директории проекта:
        ```bash
        python main.py
        ```
    *   Результат будет записан в файл `output.txt`. Для приведенного выше примера `input.txt` содержимое `output.txt` будет:
        ```
        1 1 3
        0 0 0 
        0 4 3 
        ```
        *(Примечание: Для `aaa bb` вывод `0 0 0` корректен, так как длина 0, индексы могут быть любыми. Для `aabaa babbaab` вывод `2 3 3` также был бы корректен).*

## Тестирование

Для запуска автоматических тестов выполните команду из корневой директории проекта:

```bash
python -m unittest discover tests
