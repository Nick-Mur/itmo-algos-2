# Поиск паттерна с несовпадениями

Программа находит все вхождения строки-образца `p` в строку текста `t` с не более чем `k` несовпадками (по расстоянию Хэмминга).

## Оглавление

- [Описание задачи](#описание-задачи)
- [Особенности реализации](#особенности-реализации)
- [Структура проекта](#структура-проекта)
- [Формат ввода](#формат-ввода-inputtxt)
- [Формат вывода](#формат-вывода-outputtxt)
- [Алгоритм](#алгоритм)
- [Использование](#использование)
- [Тестирование](#тестирование)
- [Ограничения](#ограничения)
- [Рефакторинг и оптимизация](#рефакторинг-и-оптимизация)

---

## Описание задачи

Для заданных целого числа `k`, строки текста `t` и строки-образца `p` необходимо найти все индексы `i` (0-based), такие что подстрока `t[i:i+|p|]` отличается от `p` не более чем на `k` символов.

Задача актуальна для:

- текстового поиска (устойчивость к опечаткам),
- биоинформатики (поиск последовательностей с мутациями).


## Особенности реализации

- **Двойное полиномиальное хеширование** для быстрого сравнения подстрок за `O(1)` после предварительной обработки.
- **Бинарный поиск** для нахождения длины совпадающих префиксов между образцом и подстрокой текста.
- Ассимптотическая сложность: `O(|t| * k * log |p|)`.


## Структура проекта

```
pattern_matcher/
├── main.py                # Точка входа: чтение/запись, запуск поиска
├── core/
│   ├── __init__.py
│   ├── hashing.py         # Полиномиальное хеширование (класс Hasher)
│   └── matcher.py         # Алгоритм поиска (функция find_matches)
├── tests/
│   ├── __init__.py
│   ├── unit/
│   │   ├── test_hashing.py
│   │   └── test_matcher.py
│   └── integration/
│       ├── test_main_flow.py
│       └── fixtures/     # Тестовые данные
│           ├── case_example_input.txt
│           └── case_example_output.txt
├── input.txt              # Файл ввода по умолчанию
├── output.txt             # Файл вывода по умолчанию
└── README.md              # Документация проекта
```


## Формат ввода (`input.txt`)

Каждая строка входного файла содержит три элемента через пробел:
1. Целое `k` — максимальное число несовпадений.
2. Строка текста `t` (латинские строчные буквы).
3. Строка-образец `p` (латинские строчные буквы).

**Пример**:
```txt
0 ababab baaa
1 ababab baaa
2 xabcabc ccc
```


## Формат вывода (`output.txt`)

Для каждой тройки `k`, `t`, `p` выводится отдельная строка:
1. Число `l` — количество найденных вхождений.
2. `l` индексов (0-based) в возрастающем порядке.

**Пример**:
```txt
0
1 1
4 1 2 3 4
```


## Алгоритм

1. **Предварительная обработка**
   - Вычисляются префиксные полиномиальные хеши для `t` и `p` (двойное хеширование).
2. **Итерация по позициям**
   - Для каждого `i` от `0` до `|t| - |p|`:
     1. Сравниваем `p` и `t[i:]` с помощью бинарного поиска LCP (longest common prefix).
     2. После каждого совпавшего префикса фиксируем возможное несовпадение и двигаем указатель.
     3. Считаем количество несовпадений; если оно не превышает `k`, добавляем `i` в результат.
3. **Вывод**
   - Форматируем результаты и записываем в `output.txt`.


## Использование

1. Поместите входные данные в `input.txt`.
2. Запустите:
   ```bash
   python main.py
   ```
3. Результат появится в файле `output.txt`.


## Тестирование

Запуск всех тестов:
```bash
python -m unittest discover tests
```

Запуск конкретного модуля:
```bash
python -m unittest tests.unit.test_matcher
python -m unittest tests.integration.test_main_flow
```


## Ограничения

- `0 ≤ k ≤ 5`
- `1 ≤ |t| ≤ 200_000`
- `1 ≤ |p| ≤ min(|t|, 100_000)`
- Суммарная длина всех `t` ≤ 200_000
- Суммарная длина всех `p` ≤ 100_000
- Время (Python): 40 секунд
- Память: 512 МБ


## Рефакторинг и оптимизация

- **core/hashing.py**: чистая реализация двойного хеширования, предвычисление степеней, обработка `IndexError`.
- **core/matcher.py**: уточнена логика бинарного поиска LCP, добавлен ранний выход при `mismatches > k`, учтены граничные случаи.
- **main.py**: улучшена обработка ошибок I/O (try-except), аккумулирование результатов и единоразовая запись в файл.

Дальнейшие улучшения:
- Тонкая настройка параметров хеширования.
- Использование алгоритмов на основе FFT для больших `k`, если потребуется.

